---
title: "assignment-2"
author: "Célia Richy"
date: "13/10/2018"
output: html_document
---
```{r}
`%>%` <- magrittr::`%>%`
```


##### Exercise 1


```{r, cache= T}
source("assignment-2.R")
if(!exists(".Random.seed")) set.seed(NULL)
previous_seed <- .Random.seed
set.seed(1)
ptest_1 <- permutation_twogroups(iris_subset_1, "Sepal.Width", "Species", "versicolor",
                                 "virginica", difference_in_means, n_samples=9999)
ptest_2 <- permutation_twogroups(iris_subset_2, "Sepal.Width", "Species", "versicolor",
                                 "virginica", difference_in_means, n_samples=9999)
set.seed(previous_seed)
print(ptest_1)
print(ptest_2)
```
```{r}
ptest_1 <- tibble::as_tibble(ptest_1["permuted"])
# création de l'histogramme partant des données ptest_d.
ptest_hist1 <- ggplot2::ggplot(data=ptest_1, ggplot2::aes(ptest_1$permuted)) + ggplot2::geom_histogram()
# ajout de la ligne à l'intercept de x. Par contre, je n'ai aucune idée de la signification de #cet intercept.
ptest_hist1 <- ptest_hist1 + ggplot2::xlim(-0.6,0.6)
ptest_hist1 <- ptest_hist1 + ggplot2::geom_vline(xintercept = -0.3133333)
print(ptest_hist1)

ptest_2 <- tibble::as_tibble(ptest_2["permuted"])
ptest_hist2 <- ggplot2::ggplot(data=ptest_2, ggplot2::aes(ptest_2$permuted)) + ggplot2::geom_histogram()
# ajout de la ligne à l'intercept de x. Par contre, je n'ai aucune idée de la signification de #cet intercept.
ptest_hist2 <- ptest_hist2 + ggplot2::xlim(-0.6,0.6)
ptest_hist2 <- ptest_hist2 + ggplot2::geom_vline(xintercept = -0.2142857)
print(ptest_hist2)
```
Il y a des différences entre les deux histogrammes parce que les deux subsets ne contiennent pas le même nombre de données, et donc pas les mêmes données non plus. De ce fait, la statistique observée ne peut pas être la même non plus puisque les données comparées ne sont pas les mêmes.

```{r}
p_value_right_1 <- permutation_pvalue_right(ptest_1$difference_in_means, -0.3133333)
p_value_left_1 <- permutation_pvalue_left(ptest_1$difference_in_means, -0.3133333)
p_value_twosided_1 <- permutation_pvalue_twosided(ptest_1$difference_in_means, -0.3133333)

p_value_right_2 <- permutation_pvalue_right(ptest_2$difference_in_means, -0.2142857)
p_value_left_2 <- permutation_pvalue_left(ptest_2$difference_in_means, -0.2142857)
p_value_twosided_2 <- permutation_pvalue_twosided(ptest_2$difference_in_means,  -0.2142857)
```



##### Exercise 2

###### Task A

```{r}
#création d'un subset contenant les dictionnaires "W1802", "J1917" et "C1687" grâce à l'opérateur "ou"
stress_shift_3dict <- dplyr::filter(stressshift::stress_shift_unamb, 
                                    Dict == "W1802" |
                                    Dict == "J1917" |  
                                    Dict == "C1687")
                                
#on imprime le nombre de rang de ce subset pour vérifier qu'on en a bien 451
print(nrow(stress_shift_3dict))
```


###### Task B

```{r}
                                  # on commence par appeler le dataset en question
stress_shift_3dict_using_pipe <- stressshift::stress_shift_unamb %>%
                                  subset(Dict == "W1802" |       #puis on crée le subset
                                    Dict == "J1917" |  
                                    Dict == "C1687")
identical(stress_shift_3dict, stress_shift_3dict_using_pipe)                                 
```

###### Task C

```{r}
#création du subset qui ne prend que les noms dans la colonne "category"
stress_shift_3dict_nouns <- dplyr::filter(stress_shift_3dict, Category == "Noun")
#création du subset qui ne prend que les verbs dans la colonne "category"
stress_shift_3dict_verbs <- dplyr::filter(stress_shift_3dict, Category == "Verb")
#création de la nouvelle data frame combinant les verbes et les noms
stress_shift_3dict_using_bind <- dplyr::bind_rows(stress_shift_3dict_nouns, stress_shift_3dict_verbs)
#puis on inverse l'ordre
stress_shift_3dict_using_bind_reversed <- dplyr::bind_rows(stress_shift_3dict_verbs,
                                                           stress_shift_3dict_nouns)
print(stress_shift_3dict_using_bind_reversed)
#on vérifie lequel de ces deux nouveaux dataframes est identique à stress_shift_3dict
identical(stress_shift_3dict, stress_shift_3dict_using_bind)
#on vérifie lequel de ces deux nouveaux dataframes est identique à stress_shift_3dict
identical(stress_shift_3dict, stress_shift_3dict_using_bind_reversed)
```
"Stress_shift_using_bind" est identique à "stress_shift_3dict" mais pas le dataframe reversed tout simplement parce que l'ordre de reversed ne correspond plus exactement à l'ordre donné dans "stress_shift_3dict". Dans ce dataframe, il apparait que les noms sont donnés avant les verbes.
Je ne pense pas que l'ordre des éléments "noms" ou "verbe" importe puisque dans tous les cas les données restent les mêmes.

###### Task D

```{r}
#on crée un subset du grand dataframe contenant seulement les noms
stress_shift_nouns <- dplyr::filter(stressshift::stress_shift_unamb, Category == "Noun")
#puis on sélectionne seulement les colonnes word, dict et syllabe
stress_shift_selected <- dplyr::select(stress_shift_nouns, Word, Dict, Syllable)
#enfin, on renomme la variable Syllable en "Syllable_Noun"
stress_shift_nouns_renamed <- dplyr::rename(stress_shift_selected, Syllable_Noun = Syllable)

#On refait exactement la même chose pour les verbes
stress_shift_verbs <- dplyr::filter(stressshift::stress_shift_unamb, Category == "Verb")
stress_shift_v_selected <- dplyr::select(stress_shift_verbs, Word, Dict, Syllable)
stress_shift_verbs_renamed <- dplyr::rename(stress_shift_v_selected, Syllable_Verb = Syllable)

#on combine les deux tableaux
stress_shift_wide <- dplyr::inner_join(stress_shift_nouns_renamed, stress_shift_verbs_renamed)
```

Selon la description donnée dans "HELP", inner_join permet de sortir tous les rangs dont les valeurs de x sont les mêmes que les valeurs de y. Ici donc il s'agit des valeurs de "word", "dict" et "syllabe" qui sont identique pour les noms (x) et les verbes (y). De ce fait, lorsque les noms et les verbes (pour chaque rang) ont des valeurs différentes, soit parce que le dictionnaire n'est pas le même, le nombre de syllabes, ou que les mots ne matchent pas, les valeurs ne sont pas ajoutées à ce nouveau tableau. Ceci explique donc pourquoi il y a moins de rangs dans ce nouveau tableau. Toutes les données de "noms" et de "verbes" ne matchent pas à 100%, et certaines donc ne sont pas gardées.

###### Task E

```{r}
#on créé un histogrammme en donnant les données, l'axe x et comment sont remplies les barres
double_bar_plot <- ggplot2::ggplot(stressshift::stress_shift_unamb,
                                   ggplot2::aes_string(x = "Category", fill = "Syllable"))
#on donne la forme de l'histogramme
double_bar_plot <- double_bar_plot + ggplot2::geom_bar()
print(double_bar_plot)
```

###### Task F

```{r}

#Noun_Percent_Syll <- as.numeric(Noun_Percent_Syll)
#Verb_Percent_Syll <- as.numeric(Verb_Percent_Syll)
  
for (i in nrow(stress_shift_wide$Word)) {
  Noun_Percent_Syll <- 0
  Verb_Percent_Syll <- 0
  if (stress_shift_wide[[Syllable_Noun]] == "Syllable 1") {
    Noun_Percent_Syll[i] <- + 1
  }
  Noun_Percent_Syll_1 <- Noun_Percent_Syll / sum(Noun_Percent_Syll)
  
  if (stress_shift_wide[[Syllable_Verb]] == "Syllable 1") {
    Verb_Percent_Syll[i] <- + 1
  }
  Verb_Percent_Syll_1 <- Verb_Percent_Syll / sum(Verb_Percent_Syll)
}
grouped_DF <- dplyr::group_by(stress_shift_wide, Word)
stress_shift_byword <- dplyr::summarise(grouped_DF)


```

```{r}
#autre tentative de faire cette tache

Noun_Percent_Syll <- dplyr::filter(stress_shift_wide, Syllable_Noun == "Syllable 1")
Verb_Percent_Syll <- dplyr::filter(stress_shift_wide, Syllable_Verb == "Syllable 1")
#syll_1_df <- dplyr::inner_join(Noun_Percent_Syll, Verb_Percent_Syll)
#stress_shift_wide_2 <- merge(stress_shift_wide, syll_1_df, all.x = TRUE)
#print(stress_shift_wide_2)



for (i in nrow(Noun_Percent_Syll)) {
  Noun_Percent_Syll <- 0
  Noun_Percent_Syll[i] <- as.numeric(Noun_Percent_Syll) + 1
  Noun_Percent_Syll_1[i] <- Noun_Percent_Syll / nrow(stress_shift_wide)
  }
  
  print(Noun_Percent_Syll)
  
  #if (stress_shift_wide$Syllable_Verb == "Syllable 1") {
for (i in nrow(Verb_Percent_Syll)) {
  Verb_Percent_Syll[i] <- as.numeric(Verb_Percent_Syll) + 1 
}
  Verb_Percent_Syll_1 <- Verb_Percent_Syll / nrow(stress_shift_wide)

grouped_DF <- dplyr::group_by(stress_shift_wide, Word, Syllable_Noun, Syllable_Verb)
stress_shift_byword <- dplyr::summarise(grouped_DF) #Noun_Percent_Syll_1,
                                                    #Verb_Percent_Syll_1)

```







#### Exercise 3


```{r}
# on attribue une distribution normale pour les deux groupes en fonction des instructions données
value_A <- rnorm(50, mean = 3, sd = 2)
value_B <- rnorm(50, mean = 4, sd = 2)

# on crée d'abord un mini dataset ne contenant que les valeurs du groupe A auquel on associe
# l'étiquette "A" dans la colonne group
data_x <- data.frame("value" = value_A, "group" = "A")

# on procède de la même manière pour le deuxième groupe de valeurs
data_y <- data.frame("value" = value_B, "group" = "B")

# on combine les deux datasets 
my_data <- rbind(data_x, data_y) # de cette façon, dans la colonne group, on a le bon label
                                 # pour le bon groupe de valeurs

# on set le seed à 12
set.seed(12)
set.seed(NULL)
```
```{r}
t.test(value_A, value_B)
```
```{r}
value_A <- rnorm(5, mean = 3, sd = 2)
value_B <- rnorm(5, mean = 4, sd = 2)
t.test(value_A, value_B)
```




